import { EventsRepo } from '../db/repos/index.js';
import { createLogger } from '../logger/index.js';

const logger = createLogger('events:audit');

export type AuditEventType = 
  | 'email.received'
  | 'email.classified'
  | 'email.extracted'
  | 'email.processed'
  | 'email.failed'
  | 'draft.created'
  | 'draft.modified'
  | 'draft.approved'
  | 'draft.sent'
  | 'draft.failed'
  | 'calendar.slot_held'
  | 'calendar.slot_confirmed'
  | 'calendar.slot_released'
  | 'system.error'
  | 'system.warning'
  | 'user.action';

export interface AuditPayload {
  [key: string]: unknown;
  timestamp?: string;
  user?: string;
  ip?: string;
  session?: string;
}

class AuditLogger {
  private eventsRepo: EventsRepo;

  constructor() {
    this.eventsRepo = new EventsRepo();
  }

  /**
   * Fügt ein Audit-Event hinzu
   */
  appendEvent(
    emailId: number | null,
    type: AuditEventType,
    payload: AuditPayload
  ): void {
    try {
      const enrichedPayload = {
        ...payload,
        timestamp: payload.timestamp || new Date().toISOString(),
        source: 'audit',
      };

      const eventId = this.eventsRepo.append(emailId, type, enrichedPayload);
      
      logger.debug(
        { eventId, emailId, type, payload: enrichedPayload },
        'Audit-Event gespeichert'
      );
    } catch (error) {
      logger.error(
        { error, emailId, type, payload },
        'Fehler beim Speichern des Audit-Events'
      );
    }
  }

  /**
   * Loggt den Empfang einer E-Mail
   */
  logEmailReceived(emailId: number, messageId: string, from: string): void {
    this.appendEvent(emailId, 'email.received', {
      message_id: messageId,
      from_email: from,
      action: 'received',
    });
  }

  /**
   * Loggt die Klassifizierung einer E-Mail
   */
  logEmailClassified(
    emailId: number,
    classification: string,
    confidence: number,
    modelUsed?: string
  ): void {
    this.appendEvent(emailId, 'email.classified', {
      classification,
      confidence,
      model_used: modelUsed,
      action: 'classified',
    });
  }

  /**
   * Loggt extrahierte Daten
   */
  logDataExtracted(
    emailId: number,
    dataType: string,
    fieldsExtracted: number,
    confidence: number
  ): void {
    this.appendEvent(emailId, 'email.extracted', {
      data_type: dataType,
      fields_extracted: fieldsExtracted,
      confidence,
      action: 'extracted',
    });
  }

  /**
   * Loggt die Erstellung eines Entwurfs
   */
  logDraftCreated(
    emailId: number,
    draftId: number,
    template: string,
    autoGenerated = true
  ): void {
    this.appendEvent(emailId, 'draft.created', {
      draft_id: draftId,
      template_used: template,
      auto_generated: autoGenerated,
      action: 'created',
    });
  }

  /**
   * Loggt die Genehmigung eines Entwurfs
   */
  logDraftApproved(
    emailId: number,
    draftId: number,
    approvedBy: string,
    modified = false
  ): void {
    this.appendEvent(emailId, 'draft.approved', {
      draft_id: draftId,
      approved_by: approvedBy,
      was_modified: modified,
      action: 'approved',
    });
  }

  /**
   * Loggt das Versenden eines Entwurfs
   */
  logDraftSent(emailId: number, draftId: number, to: string, method = 'smtp'): void {
    this.appendEvent(emailId, 'draft.sent', {
      draft_id: draftId,
      to_email: to,
      send_method: method,
      action: 'sent',
    });
  }

  /**
   * Loggt einen Fehler
   */
  logError(
    emailId: number | null,
    error: Error | string,
    context?: Record<string, unknown>
  ): void {
    const errorMessage = error instanceof Error ? error.message : error;
    const errorStack = error instanceof Error ? error.stack : undefined;

    this.appendEvent(emailId, 'system.error', {
      error_message: errorMessage,
      error_stack: errorStack,
      context,
      severity: 'error',
    });
  }

  /**
   * Loggt eine Warnung
   */
  logWarning(
    emailId: number | null,
    message: string,
    context?: Record<string, unknown>
  ): void {
    this.appendEvent(emailId, 'system.warning', {
      warning_message: message,
      context,
      severity: 'warning',
    });
  }

  /**
   * Loggt eine Benutzeraktion
   */
  logUserAction(
    emailId: number | null,
    action: string,
    user: string,
    details?: Record<string, unknown>
  ): void {
    this.appendEvent(emailId, 'user.action', {
      action,
      user,
      details,
    });
  }

  /**
   * Loggt Calendar-Slot-Operationen
   */
  logCalendarOperation(
    operation: 'held' | 'confirmed' | 'released',
    slotId: number,
    emailId?: number,
    details?: Record<string, unknown>
  ): void {
    const eventType = `calendar.slot_${operation}` as AuditEventType;
    
    this.appendEvent(emailId || null, eventType, {
      slot_id: slotId,
      operation,
      ...details,
    });
  }

  /**
   * Holt Audit-Events für eine E-Mail
   */
  getEmailAuditTrail(emailId: number): Array<{
    type: string;
    timestamp: string;
    data: Record<string, unknown>;
  }> {
    const events = this.eventsRepo.findByEmailId(emailId);
    
    return events.map(event => {
      let data = {};
      try {
        data = event.data ? JSON.parse(event.data) : {};
      } catch {
        // Ignore parse errors
      }

      return {
        type: event.event_type,
        timestamp: event.created_at,
        data: data as Record<string, unknown>,
      };
    });
  }

  /**
   * Generiert einen Audit-Report
   */
  generateAuditReport(
    startDate: Date,
    endDate: Date
  ): {
    totalEvents: number;
    byType: Record<string, number>;
    errors: number;
    warnings: number;
  } {
    const stats = this.eventsRepo.getEventStats();
    
    return {
      totalEvents: Object.values(stats).reduce((sum, count) => sum + count, 0),
      byType: stats,
      errors: stats['system.error'] || 0,
      warnings: stats['system.warning'] || 0,
    };
  }
}

// Singleton-Export
export const auditLogger = new AuditLogger();